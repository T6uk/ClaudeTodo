<!-- app/templates/games/play/puzzle/memory_match.html -->
{% extends "games/play/game_base.html" %}

{% block game_head %}
<style>
    .memory-match-container {
        max-width: 800px;
        margin: 0 auto;
        text-align: center;
    }

    .game-board {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 12px;
        margin: 0 auto;
        max-width: 550px;
    }

    .card-container {
        perspective: 1000px;
        aspect-ratio: 3/4;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .card-container:hover {
        transform: translateY(-5px);
    }

    .memory-card {
        width: 100%;
        height: 100%;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    .card-container.flipped .memory-card {
        transform: rotateY(180deg);
    }

    .card-front, .card-back {
        width: 100%;
        height: 100%;
        position: absolute;
        backface-visibility: hidden;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .card-front {
        background: linear-gradient(135deg, #A1B2D4 0%, #8090B2 100%);
        color: white;
        font-size: 2.5rem;
    }

    .card-back {
        background-color: white;
        transform: rotateY(180deg);
        color: #333;
        font-size: 3rem;
    }

    [data-bs-theme="dark"] .card-back {
        background-color: #343a40;
        color: #f8f9fa;
    }

    .matched .memory-card {
        animation: pulse-matched 1.5s infinite alternate;
    }

    .matched .card-back {
        background-color: rgba(87, 167, 115, 0.2);
        box-shadow: 0 0 15px rgba(87, 167, 115, 0.5);
    }

    [data-bs-theme="dark"] .matched .card-back {
        background-color: rgba(87, 167, 115, 0.3);
    }

    .game-stats {
        display: flex;
        justify-content: space-around;
        margin: 20px auto;
        max-width: 550px;
    }

    .stat-item {
        text-align: center;
        padding: 12px 20px;
        background-color: #f8f9fa;
        border-radius: 12px;
        min-width: 100px;
        transition: all 0.3s ease;
    }

    .stat-item:hover {
        transform: translateY(-5px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    [data-bs-theme="dark"] .stat-item {
        background-color: #343a40;
    }

    .stat-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: var(--primary);
    }

    .stat-label {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin-top: 5px;
    }

    .level-select {
        margin: 20px auto;
        text-align: center;
    }

    .theme-select {
        margin: 0 auto 20px;
        text-align: center;
    }

    .progress-bar {
        height: 10px;
        border-radius: 5px;
        margin: 20px auto;
        overflow: hidden;
        background-color: #e9ecef;
        max-width: 550px;
    }

    .progress-value {
        height: 100%;
        border-radius: 5px;
        background-color: var(--primary);
        transition: width 1s linear;
    }

    /* Game feedback toasts */
    .game-toast {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 20px;
        font-weight: 600;
        z-index: 1000;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .combo-counter {
        position: absolute;
        font-size: 1.5rem;
        font-weight: 700;
        color: #57A773;
        opacity: 0;
        transition: all 0.3s ease;
    }

    /* Enhanced animations */
    @keyframes match-success {
        0% {transform: scale(1);}
        50% {transform: scale(1.1);}
        100% {transform: scale(1);}
    }

    .match-success {
        animation: match-success 0.6s;
    }

    @keyframes match-fail {
        0%, 100% {transform: translateX(0);}
        20%, 60% {transform: translateX(-5px);}
        40%, 80% {transform: translateX(5px);}
    }

    .match-fail {
        animation: match-fail 0.4s;
    }

    @keyframes pulse-matched {
        0% {transform: rotateY(180deg) scale(1);}
        100% {transform: rotateY(180deg) scale(1.05);}
    }

    @keyframes fade-up {
        0% {opacity: 1; transform: translateY(0);}
        100% {opacity: 0; transform: translateY(-50px);}
    }

    @keyframes show-toast {
        0% {opacity: 0; transform: translate(-50%, -20px);}
        20% {opacity: 1; transform: translate(-50%, 0);}
        80% {opacity: 1; transform: translate(-50%, 0);}
        100% {opacity: 0; transform: translate(-50%, -20px);}
    }

    .show-toast {
        animation: show-toast 2s ease forwards;
    }

    .streak-animation {
        animation: fade-up 1.5s ease forwards;
    }

    /* Difficulty stars */
    .difficulty-stars {
        margin-bottom: 10px;
        color: var(--primary);
    }

    /* Game variant selector */
    .variant-selector {
        margin: 10px auto;
        display: flex;
        justify-content: center;
        gap: 10px;
    }

    .variant-btn {
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        border: 2px solid var(--primary);
        background-color: transparent;
        color: var(--primary);
        transition: all 0.3s ease;
    }

    .variant-btn.active {
        background-color: var(--primary);
        color: white;
    }

    .variant-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
    }

    /* Game completion celebratory animation */
    @keyframes celebrate {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.2); }
    }

    .celebrate {
        animation: celebrate 0.5s ease-in-out 3;
    }

    /* Game progress indicator */
    .progress-indicator {
        margin: 15px auto;
        max-width: 550px;
        height: 8px;
        background-color: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
    }

    .progress-indicator-value {
        height: 100%;
        background-color: #57A773;
        width: 0%;
        transition: width 0.3s ease;
    }

    /* Sound toggle button */
    .sound-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        font-size: 1.2rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .sound-toggle:hover {
        background-color: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
    }
</style>
{% endblock %}

{% block game_content %}
<div class="memory-match-container position-relative">
    <button class="sound-toggle" id="soundToggle" title="Toggle sound">
        <i class="fas fa-volume-up" id="soundIcon"></i>
    </button>

    <div class="game-stats">
        <div class="stat-item">
            <div class="stat-value" id="scoreDisplay">0</div>
            <div class="stat-label">Score</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="movesDisplay">0</div>
            <div class="stat-label">Moves</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="timeDisplay">0:00</div>
            <div class="stat-label">Time</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="comboDisplay">0</div>
            <div class="stat-label">Combo</div>
        </div>
    </div>

    <!-- Progress matches indicator -->
    <div class="progress-indicator">
        <div class="progress-indicator-value" id="matchesProgress"></div>
    </div>

    <div class="level-select mb-3">
        <div class="difficulty-stars mb-2" id="difficultyStars">
            <i class="fas fa-star"></i>
            <i class="fas fa-star"></i>
            <i class="far fa-star"></i>
        </div>
        <label for="levelSelect" class="form-label">Difficulty:</label>
        <select id="levelSelect" class="form-select form-select-sm d-inline-block w-auto">
            <option value="easy">Easy (4Ã—3)</option>
            <option value="medium" selected>Medium (4Ã—4)</option>
            <option value="hard">Hard (6Ã—4)</option>
            <option value="expert">Expert (6Ã—5)</option>
        </select>
    </div>

    <div class="theme-select">
        <label for="themeSelect" class="form-label">Card Theme:</label>
        <select id="themeSelect" class="form-select form-select-sm d-inline-block w-auto">
            <option value="animals" selected>Animals</option>
            <option value="fruits">Fruits</option>
            <option value="transport">Transport</option>
            <option value="space">Space</option>
            <option value="emotions">Emotions</option>
        </select>
    </div>

    <div class="variant-selector">
        <button class="variant-btn active" data-variant="classic">Classic</button>
        <button class="variant-btn" data-variant="timed">Timed</button>
        <button class="variant-btn" data-variant="challenge">Challenge</button>
    </div>

    <div class="progress-bar">
        <div class="progress-value" id="progressBar" style="width: 100%;"></div>
    </div>

    <div id="gameBoard" class="game-board">
        <!-- Memory cards will be generated here -->
    </div>

    <!-- Toast for game feedback -->
    <div id="gameToast" class="game-toast"></div>
</div>
{% endblock %}

{% block game_controls %}
<button id="startButton" class="btn btn-primary me-2">
    <i class="fas fa-play me-1"></i> Start Game
</button>
<button id="resetButton" class="btn btn-secondary">
    <i class="fas fa-redo me-1"></i> Reset
</button>
{% endblock %}

{% block game_scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Game variables
        let cards = [];
        let hasFlippedCard = false;
        let lockBoard = false;
        let firstCard, secondCard;
        let score = 0;
        let moves = 0;
        let matches = 0;
        let timeLeft = 60;
        let totalPairs = 8;  // Default for medium difficulty
        let gameTimer;
        let startTime;
        let gameActive = false;
        let combo = 0;
        let maxCombo = 0;
        let gameVariant = 'classic';
        let soundEnabled = true;
        let gamePaused = false;
        let gameEnded = false; // Add a flag to prevent multiple end game calls

        // Card symbols by theme (unicode symbols and emojis)
        const cardSymbols = {
            animals: ['ðŸ¶', 'ðŸ±', 'ðŸ°', 'ðŸ¦Š', 'ðŸ»', 'ðŸ¼', 'ðŸ¦', 'ðŸ¯', 'ðŸ¨', 'ðŸ®', 'ðŸ·', 'ðŸ¸', 'ðŸ¦„', 'ðŸ¦“', 'ðŸ¦’'],
            fruits: ['ðŸŽ', 'ðŸ', 'ðŸŠ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸ¥¥', 'ðŸ†', 'ðŸ¥‘'],
            transport: ['ðŸš—', 'ðŸš•', 'ðŸš™', 'ðŸšŒ', 'ðŸšŽ', 'ðŸŽ', 'ðŸš“', 'ðŸš‘', 'ðŸš’', 'ðŸšš', 'ðŸš›', 'âœˆï¸', 'ðŸš‚', 'ðŸš¢', 'ðŸ›µ'],
            space: ['ðŸš€', 'ðŸŒŽ', 'ðŸŒ™', 'â­', 'â˜„ï¸', 'ðŸŒž', 'ðŸŒš', 'ðŸª', 'ðŸŒŒ', 'ðŸŒ ', 'ðŸ‘¨â€ðŸš€', 'ðŸ‘½', 'ðŸ›¸', 'ðŸ”­', 'ðŸŒŸ'],
            emotions: ['ðŸ˜€', 'ðŸ˜‚', 'ðŸ˜', 'ðŸ¤”', 'ðŸ˜Ž', 'ðŸ¥³', 'ðŸ˜´', 'ðŸ¤¯', 'ðŸ˜±', 'ðŸ™„', 'ðŸ¤©', 'ðŸ˜‡', 'ðŸ¥º', 'ðŸ˜¤', 'ðŸ¤ª']
        };

        // Game sounds
        const sounds = {
            flip: new Audio('https://freesound.org/data/previews/240/240776_4107740-lq.mp3'),
            match: new Audio('https://freesound.org/data/previews/131/131660_2398403-lq.mp3'),
            wrong: new Audio('https://freesound.org/data/previews/142/142608_1840739-lq.mp3'),
            win: new Audio('https://freesound.org/data/previews/320/320775_5260872-lq.mp3'),
            timeTick: new Audio('https://freesound.org/data/previews/254/254316_4404552-lq.mp3'),
            levelUp: new Audio('https://freesound.org/data/previews/270/270404_5123851-lq.mp3')
        };

        // Preload sounds
        for (const sound in sounds) {
            sounds[sound].load();
            sounds[sound].volume = 0.4;
        }

        // Play sound if enabled
        function playSound(sound) {
            if (soundEnabled && sounds[sound]) {
                sounds[sound].currentTime = 0;
                sounds[sound].play().catch(e => console.log("Audio play error:", e));
            }
        }

        // DOM elements
        const gameBoard = document.getElementById('gameBoard');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const movesDisplay = document.getElementById('movesDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const comboDisplay = document.getElementById('comboDisplay');
        const progressBar = document.getElementById('progressBar');
        const matchesProgress = document.getElementById('matchesProgress');
        const levelSelect = document.getElementById('levelSelect');
        const themeSelect = document.getElementById('themeSelect');
        const difficultyStars = document.getElementById('difficultyStars');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const gameToast = document.getElementById('gameToast');
        const variantButtons = document.querySelectorAll('.variant-btn');
        const soundToggle = document.getElementById('soundToggle');
        const soundIcon = document.getElementById('soundIcon');

        // Set up difficulty settings
        const DIFFICULTY = {
            easy: { rows: 3, cols: 4, timeLimit: 60, timePerMatch: 5, basePoints: 10 },
            medium: { rows: 4, cols: 4, timeLimit: 90, timePerMatch: 4, basePoints: 15 },
            hard: { rows: 4, cols: 6, timeLimit: 120, timePerMatch: 3, basePoints: 20 },
            expert: { rows: 5, cols: 6, timeLimit: 150, timePerMatch: 2, basePoints: 25 }
        };

        // Game variants
        const VARIANTS = {
            classic: {
                description: "Match all pairs without time pressure",
                setup: function() {
                    const difficulty = levelSelect.value;
                    timeLeft = DIFFICULTY[difficulty].timeLimit;
                    progressBar.style.display = 'none';
                }
            },
            timed: {
                description: "Race against the clock to match all pairs",
                setup: function() {
                    const difficulty = levelSelect.value;
                    timeLeft = DIFFICULTY[difficulty].timeLimit;
                    progressBar.style.display = 'block';
                }
            },
            challenge: {
                description: "Limited moves to find all matches",
                setup: function() {
                    // Calculate max moves based on difficulty
                    const difficulty = levelSelect.value;
                    const totalCards = DIFFICULTY[difficulty].rows * DIFFICULTY[difficulty].cols;
                    // Set max moves to 1.5x the number of pairs
                    const maxMoves = Math.floor(totalCards * 0.75);

                    // Display moves left instead of time
                    timeLeft = maxMoves;
                    timeDisplay.textContent = timeLeft;
                    document.querySelector('.stat-item:nth-child(3) .stat-label').textContent = 'Moves Left';

                    progressBar.style.display = 'block';
                }
            }
        };

        // Show toast message
        function showToast(message) {
            gameToast.textContent = message;
            gameToast.classList.remove('show-toast');
            // Trigger reflow to restart animation
            void gameToast.offsetWidth;
            gameToast.classList.add('show-toast');
        }

        // Update difficulty stars display
        function updateDifficultyStars() {
            const difficulty = levelSelect.value;
            let stars = '';

            switch(difficulty) {
                case 'easy':
                    stars = '<i class="fas fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i>';
                    break;
                case 'medium':
                    stars = '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="far fa-star"></i>';
                    break;
                case 'hard':
                    stars = '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i>';
                    break;
                case 'expert':
                    stars = '<i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i>';
                    break;
            }

            difficultyStars.innerHTML = stars;
        }

        // Update matches progress indicator
        function updateMatchesProgress() {
            const percentage = (matches / totalPairs) * 100;
            matchesProgress.style.width = `${percentage}%`;
        }

        // Set up initial game state
        function initGame() {
            // Clear any existing timer
            clearInterval(gameTimer);

            // Reset game state
            cards = [];
            hasFlippedCard = false;
            lockBoard = true;
            firstCard = null;
            secondCard = null;
            score = 0;
            moves = 0;
            matches = 0;
            combo = 0;
            maxCombo = 0;
            gamePaused = false;
            gameEnded = false; // Reset game ended flag

            // Get difficulty settings
            const difficulty = levelSelect.value;

            // Setup based on game variant
            VARIANTS[gameVariant].setup();

            // Update star rating
            updateDifficultyStars();

            // Set game to inactive
            gameActive = false;

            // Update displays
            scoreDisplay.textContent = '0';
            movesDisplay.textContent = '0';
            comboDisplay.textContent = '0';
            updateMatchesProgress();

            if (gameVariant !== 'challenge') {
                timeDisplay.textContent = formatTime(timeLeft);
                document.querySelector('.stat-item:nth-child(3) .stat-label').textContent = 'Time';
            } else {
                timeDisplay.textContent = timeLeft;
            }

            progressBar.style.width = '100%';

            // Clear the game board
            gameBoard.innerHTML = '';

            // Remove any pause overlay
            const pauseOverlay = document.getElementById('pauseOverlay');
            if (pauseOverlay) {
                pauseOverlay.remove();
            }

            // Show game variant description
            showToast(VARIANTS[gameVariant].description);

            // Set up based on selected difficulty
            setupDifficulty();
        }

        // Format time as MM:SS
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        // Set up based on selected difficulty
        function setupDifficulty() {
            const difficulty = levelSelect.value;
            const settings = DIFFICULTY[difficulty];

            const rows = settings.rows;
            const cols = settings.cols;

            // Calculate total pairs
            totalPairs = (rows * cols) / 2;

            // Update grid layout
            gameBoard.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

            // Choose the selected theme
            const theme = themeSelect.value;
            const symbols = cardSymbols[theme];

            // Create cards for pairs
            const cardPairs = [];
            for (let i = 0; i < totalPairs; i++) {
                const symbol = symbols[i % symbols.length];
                cardPairs.push(symbol);
                cardPairs.push(symbol);
            }

            // Shuffle the cards
            const shuffledCards = shuffle(cardPairs);

            // Create card elements
            for (let i = 0; i < shuffledCards.length; i++) {
                createCard(shuffledCards[i], i);
            }
        }

        // Create a card element
        function createCard(symbol, index) {
            const cardContainer = document.createElement('div');
            cardContainer.classList.add('card-container');
            cardContainer.dataset.index = index;

            const card = document.createElement('div');
            card.classList.add('memory-card');

            const cardFront = document.createElement('div');
            cardFront.classList.add('card-front');
            cardFront.innerHTML = '<i class="fas fa-question"></i>';

            const cardBack = document.createElement('div');
            cardBack.classList.add('card-back');
            cardBack.textContent = symbol;

            card.appendChild(cardFront);
            card.appendChild(cardBack);
            cardContainer.appendChild(card);

            // Add click event
            cardContainer.addEventListener('click', flipCard);

            // Add to game board and cards array
            gameBoard.appendChild(cardContainer);
            cards.push(cardContainer);
        }

        // Display a combo animation
        function showComboAnimation(x, y, comboCount) {
            const comboEl = document.createElement('div');
            comboEl.classList.add('combo-counter');
            comboEl.textContent = `${comboCount}x Combo!`;
            comboEl.style.left = `${x}px`;
            comboEl.style.top = `${y}px`;
            document.body.appendChild(comboEl);

            // Trigger animation
            setTimeout(() => {
                comboEl.style.opacity = '1';
                comboEl.style.transform = 'translateY(-20px)';

                setTimeout(() => {
                    comboEl.classList.add('streak-animation');

                    // Remove element after animation
                    setTimeout(() => {
                        comboEl.remove();
                    }, 1500);
                }, 300);
            }, 10);
        }

        // Shuffle an array (Fisher-Yates algorithm)
        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Flip card handler
        function flipCard() {
            if (lockBoard) return;
            if (this === firstCard) return;
            if (this.classList.contains('matched')) return;
            if (!gameActive || gameEnded) return;
            if (gamePaused) return;

            // Play flip sound
            playSound('flip');

            this.classList.add('flipped');

            if (!hasFlippedCard) {
                // First click
                hasFlippedCard = true;
                firstCard = this;
                return;
            }

            // Second click
            secondCard = this;
            moves++;
            movesDisplay.textContent = moves;

            // For challenge mode, decrement moves left
            if (gameVariant === 'challenge') {
                timeLeft--;
                timeDisplay.textContent = timeLeft;
                const maxMoves = DIFFICULTY[levelSelect.value].rows * DIFFICULTY[levelSelect.value].cols * 0.75;
                progressBar.style.width = (timeLeft / maxMoves * 100) + '%';

                // Check if out of moves
                if (timeLeft <= 0) {
                    setTimeout(() => {
                        outOfMoves();
                    }, 800);
                    return; // Prevent further processing
                }
            }

            checkForMatch();
        }

        // Check if the two flipped cards match
        function checkForMatch() {
            if (!firstCard || !secondCard) return; // Safety check

            // Get the symbols from both cards
            const firstSymbol = firstCard.querySelector('.card-back').textContent;
            const secondSymbol = secondCard.querySelector('.card-back').textContent;

            // Check if they match
            if (firstSymbol === secondSymbol) {
                // It's a match!
                disableCards();

                // Increment combo
                combo++;
                if (combo > maxCombo) maxCombo = combo;
                comboDisplay.textContent = combo;

                // Play match sound
                playSound('match');

                // Add match animation
                firstCard.classList.add('match-success', 'matched');
                secondCard.classList.add('match-success', 'matched');

                // Increment matches counter
                matches++;

                // Update matches progress display
                updateMatchesProgress();

                // Show combo animation if > 1
                if (combo > 1) {
                    const rect = secondCard.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top;
                    showComboAnimation(x, y, combo);
                }

                // Add points based on speed, difficulty, and combo
                const difficulty = levelSelect.value;
                const basePoints = DIFFICULTY[difficulty].basePoints;
                const comboMultiplier = 1 + (combo * 0.1); // +10% per combo
                let speedMultiplier = 1;

                // Speed multiplier based on game variant
                if (gameVariant === 'timed') {
                    const elapsedTime = (Date.now() - startTime) / 1000;
                    const averageTimePerMatch = elapsedTime / (matches + 1);
                    const expectedTime = DIFFICULTY[difficulty].timeLimit / totalPairs;
                    speedMultiplier = Math.max(0.5, Math.min(2, expectedTime / averageTimePerMatch));
                }

                const pointsEarned = Math.floor(basePoints * comboMultiplier * speedMultiplier);
                score += pointsEarned;
                updateScore(score);

                // Add time bonus for timed mode
                if (gameVariant === 'timed') {
                    const timeBonus = DIFFICULTY[difficulty].timePerMatch;
                    timeLeft += timeBonus;
                    showToast(`+${timeBonus}s Time Bonus!`);
                }

                // Check if game is complete
                if (matches >= totalPairs) {
                    console.log("All pairs matched! matches:", matches, "totalPairs:", totalPairs);

                    // Lock the board immediately to prevent further moves
                    lockBoard = true;

                    // Set a short timeout to allow animations to complete
                    setTimeout(() => {
                        if (!gameEnded) {
                            finishGame();
                        }
                    }, 800);
                }
            } else {
                // Not a match
                unflipCards();

                // Reset combo
                combo = 0;
                comboDisplay.textContent = combo;

                // Play wrong sound
                playSound('wrong');

                // Subtract points for wrong moves, but don't go below 0
                score = Math.max(0, score - 5);
                updateScore(score);

                // Add fail animation
                firstCard.classList.add('match-fail');
                secondCard.classList.add('match-fail');

                setTimeout(() => {
                    if (firstCard) firstCard.classList.remove('match-fail');
                    if (secondCard) secondCard.classList.remove('match-fail');
                }, 400);
            }
        }

// Disable matched cards
        function disableCards() {
            if (!firstCard || !secondCard) return; // Safety check

            firstCard.removeEventListener('click', flipCard);
            secondCard.removeEventListener('click', flipCard);

            resetBoard();
        }

        // Unflip non-matching cards
        function unflipCards() {
            lockBoard = true;

            setTimeout(() => {
                if (firstCard && secondCard) {
                    firstCard.classList.remove('flipped');
                    secondCard.classList.remove('flipped');
                }

                resetBoard();
            }, 1000);
        }

        // Reset board for next selection
        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        // Start the game
        function startGame() {
            if (gameActive) return;

            gameActive = true;
            gameEnded = false; // Reset game ended flag
            lockBoard = false;
            startTime = Date.now();

            // Reset counters just to be safe
            matches = 0;
            score = 0;
            moves = 0;
            combo = 0;
            maxCombo = 0;
            updateMatchesProgress();

            // Update display
            scoreDisplay.textContent = '0';
            movesDisplay.textContent = '0';
            comboDisplay.textContent = '0';

            // Reset all scores in the game system
            if (document.getElementById('finalScore')) {
                document.getElementById('finalScore').textContent = "0";
            }

            if (document.getElementById('scoreInput')) {
                document.getElementById('scoreInput').value = "0";
            }

            // Update control buttons
            startButton.disabled = true;
            levelSelect.disabled = true;
            themeSelect.disabled = true;
            variantButtons.forEach(btn => btn.disabled = true);

            // Start the timer for timed modes
            if (gameVariant === 'timed') {
                gameTimer = setInterval(updateTimer, 1000);
            }
        }

        // Update timer display
        function updateTimer() {
            if (!gameActive || gamePaused || gameEnded) return;

            timeLeft--;

            // Play a tick sound at low time
            if (timeLeft <= 10) {
                playSound('timeTick');
            }

            // Update time display
            timeDisplay.textContent = formatTime(timeLeft);

            // Update progress bar
            const difficulty = levelSelect.value;
            const maxTime = DIFFICULTY[difficulty].timeLimit;
            const percentLeft = (timeLeft / maxTime) * 100;
            progressBar.style.width = `${percentLeft}%`;

            // Change progress bar color when low on time
            if (timeLeft <= 10) {
                progressBar.style.backgroundColor = '#D76464';
            } else {
                progressBar.style.backgroundColor = 'var(--primary)';
            }

            // Check for game over
            if (timeLeft <= 0) {
                clearInterval(gameTimer);
                if (!gameEnded) {
                    timeOut();
                }
            }
        }

        // Time out - game over
        function timeOut() {
            console.log("Time out called. Current score:", score);
            if (gameEnded) return; // Prevent multiple calls

            gameEnded = true;
            lockBoard = true;
            gameActive = false;

            // Play sound
            playSound('wrong');

            // Ensure score is up-to-date in the UI
            scoreDisplay.textContent = score;

            // Make sure the hidden score input is updated
            if (document.getElementById('scoreInput')) {
                document.getElementById('scoreInput').value = score;
            }

            // Update final score display if it exists
            if (document.getElementById('finalScore')) {
                document.getElementById('finalScore').textContent = score;
            }

            // Enable buttons
            startButton.disabled = false;
            levelSelect.disabled = false;
            themeSelect.disabled = false;
            variantButtons.forEach(btn => btn.disabled = false);

            // Show message
            endGame(score, 'Time\'s up! You matched ' + matches + ' out of ' + totalPairs + ' pairs.');

            console.log("Final score sent to endGame:", score);
        }

        // Out of moves - challenge mode
        function outOfMoves() {
            console.log("Out of moves called. Current score:", score);
            if (gameEnded) return; // Prevent multiple calls

            gameEnded = true;
            lockBoard = true;
            gameActive = false;

            // Play sound
            playSound('wrong');

            // Ensure score is up-to-date in the UI
            scoreDisplay.textContent = score;

            // Make sure the hidden score input is updated
            if (document.getElementById('scoreInput')) {
                document.getElementById('scoreInput').value = score;
            }

            // Update final score display if it exists
            if (document.getElementById('finalScore')) {
                document.getElementById('finalScore').textContent = score;
            }

            // Enable buttons
            startButton.disabled = false;
            levelSelect.disabled = false;
            themeSelect.disabled = false;
            variantButtons.forEach(btn => btn.disabled = false);

            // Show message for challenge mode out of moves
            endGame(score, 'Out of moves! You matched ' + matches + ' out of ' + totalPairs + ' pairs.');

            console.log("Final score sent to endGame:", score);
        }

        // Finish game - all matches found
        function finishGame() {
            console.log("Finish game called. Score:", score, "Matches:", matches, "Total Pairs:", totalPairs);
            if (gameEnded) return; // Prevent multiple calls to finish game

            gameEnded = true;
            clearInterval(gameTimer);
            lockBoard = true;
            gameActive = false;

            // Double check that all pairs are found (safety check)
            if (matches !== totalPairs) {
                console.log("Game finished but matches don't equal totalPairs:", matches, totalPairs);
                // Force the correct value just to be safe
                matches = totalPairs;
                updateMatchesProgress(); // Update visual progress
            }

            // Play win sound
            playSound('win');
            playSound('levelUp');

            // Add celebration effect to matched cards
            document.querySelectorAll('.matched').forEach(card => {
                card.classList.add('celebrate');
            });

            // Calculate bonuses
            let timeBonus = 0;
            let movesBonus = 0;
            let comboBonus = 0;

            // Different bonuses based on game variant
            if (gameVariant === 'timed') {
                timeBonus = timeLeft * 2;
                score += timeBonus;
            } else if (gameVariant === 'challenge') {
                movesBonus = timeLeft * 5; // Remaining moves
                score += movesBonus;
            }

            // Combo bonus for all variants
            comboBonus = maxCombo * 20;
            score += comboBonus;

            // Update score display
            scoreDisplay.textContent = score;

            // Make sure the hidden score input is updated
            if (document.getElementById('scoreInput')) {
                document.getElementById('scoreInput').value = score;
            }

            // Update final score display if it exists
            if (document.getElementById('finalScore')) {
                document.getElementById('finalScore').textContent = score;
            }

            // Calculate elapsed time
            const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Enable buttons
            startButton.disabled = false;
            levelSelect.disabled = false;
            themeSelect.disabled = false;
            variantButtons.forEach(btn => btn.disabled = false);

            // Show success message with bonuses
            let message = `Great job! You completed the game in ${timeStr} with ${moves} moves.`;

            if (timeBonus > 0) {
                message += ` Time bonus: +${timeBonus} points!`;
            }

            if (movesBonus > 0) {
                message += ` Moves bonus: +${movesBonus} points!`;
            }

            if (maxCombo > 1) {
                message += ` Max combo (${maxCombo}Ã—): +${comboBonus} points!`;
            }

            // Update matches progress to 100%
            updateMatchesProgress();

            // Show success toast
            showToast('ðŸŽ‰ All pairs matched! Great job!');

            // Call the game end modal
            endGame(score, message);

            console.log("Final score sent to endGame:", score);
        }

        // Reset game
        function resetGame() {
            clearInterval(gameTimer);
            initGame();

            // Enable buttons
            startButton.disabled = false;
            levelSelect.disabled = false;
            themeSelect.disabled = false;
            variantButtons.forEach(btn => btn.disabled = false);
        }

        // Toggle sound
        function toggleSound() {
            soundEnabled = !soundEnabled;

            // Update icon
            if (soundEnabled) {
                soundIcon.className = 'fas fa-volume-up';
                showToast('Sound enabled');
            } else {
                soundIcon.className = 'fas fa-volume-mute';
                showToast('Sound muted');
            }
        }

        // Pause game
        function pauseGame() {
            if (!gameActive || gameEnded) return;

            gamePaused = !gamePaused;

            if (gamePaused) {
                // Pause the game
                clearInterval(gameTimer);
                showToast('Game paused');

                // Show a pause overlay
                const pauseOverlay = document.createElement('div');
                pauseOverlay.id = 'pauseOverlay';
                pauseOverlay.style.position = 'absolute';
                pauseOverlay.style.top = '0';
                pauseOverlay.style.left = '0';
                pauseOverlay.style.width = '100%';
                pauseOverlay.style.height = '100%';
                pauseOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                pauseOverlay.style.display = 'flex';
                pauseOverlay.style.justifyContent = 'center';
                pauseOverlay.style.alignItems = 'center';
                pauseOverlay.style.zIndex = '100';
                pauseOverlay.style.borderRadius = '15px';

                const pauseText = document.createElement('div');
                pauseText.textContent = 'PAUSED';
                pauseText.style.color = 'white';
                pauseText.style.fontSize = '2rem';
                pauseText.style.fontWeight = 'bold';

                pauseOverlay.appendChild(pauseText);
                gameBoard.parentElement.appendChild(pauseOverlay);
            } else {
                // Resume the game
                if (gameVariant === 'timed') {
                    gameTimer = setInterval(updateTimer, 1000);
                }
                showToast('Game resumed');

                // Remove pause overlay
                const pauseOverlay = document.getElementById('pauseOverlay');
                if (pauseOverlay) {
                    pauseOverlay.remove();
                }
            }
        }

        // Update game variant
        function setGameVariant(variant) {
            gameVariant = variant;

            // Update button states
            variantButtons.forEach(btn => {
                if (btn.dataset.variant === variant) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Reinitialize game with new variant
            initGame();
        }

        // Event listeners
        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', resetGame);
        levelSelect.addEventListener('change', initGame);
        themeSelect.addEventListener('change', initGame);
        soundToggle.addEventListener('click', toggleSound);

        // Variant button listeners
        variantButtons.forEach(button => {
            button.addEventListener('click', function() {
                setGameVariant(this.dataset.variant);
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Toggle sound with M key
            if (e.key.toLowerCase() === 'm') {
                toggleSound();
            }

            // Pause game with P or Escape key
            if ((e.key.toLowerCase() === 'p' || e.key === 'Escape') && gameActive && !gameEnded) {
                pauseGame();
                e.preventDefault();
            }

            // Start/restart game with Enter key
            if (e.key === 'Enter' && !gameActive) {
                startGame();
                e.preventDefault();
            }
        });

        // Initialize game
        initGame();

        // Make resetGame function available globally
        window.resetGame = resetGame;
    });
</script>
{% endblock %}